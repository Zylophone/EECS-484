%Assign synapse weights
function [T,Tabc] = assign_weights(A,B,C,D,n_cities,costs)	
   n_days = n_cities;
   
   %Fill in the T matrix
   
   %Global inhibition
   T = -C * ones(n_cities, n_days, n_cities, n_days);
   
   for x = 1:n_cities
       for y = 1:n_cities
           for i = 1:n_days
               for j = 1:n_days
                   %Penalize visiting the same city on two different days
                    if x==y && i~=j
                        T(x,i,y,j) = T(x,i,y,j) - A;
                    end
                    
   %Penalize visiting two cities on the same day
   
   
   Tabc = T;%Tabc is used for integral error feedback.  It containts weights ONLY for
   %the 3 constraints--not for the trip cost
   
   %Penalize distance (data term)
   
   
   
   %Old code begins here
	% fill in T matrix
	for X=1:N_CITIES
		for Y=1:N_CITIES
			for ix=1:N_DAYS
				for jy=1:N_DAYS
					Tabc(X,ix,Y,jy)= -C;% global inhibition
                    T(X,ix,Y,jy)  = -C;%// same for Tabc and T
					if( fixthis) % penalize if same city on two different days
                      T(X,ix,Y,jy)  =T(X,ix,Y,jy) -A;
					  Tabc(X,ix,Y,jy) =Tabc(X,ix,Y,jy) -A; 
                    end
					% penalize two cities on the same day--both T and Tabc
					if(fixThis) 
					  ...
                    end
					% distance data terms--do NOT include in Tabc
					% connect predecessor and successor city distances
					if(jy==ix-1) 
					 T(X,ix,Y,jy) =T(X,ix,Y,jy) - D*costs(X,Y);
                    end
                    %per Hopfield's summation, do same for days in reverse order
                    %ALSO, include wrap-around: city on day 10 must connect
                    %to start city (city 1) at end of trip, and reverse as
                    %well.  (need to include this term)
                end
            end
        end
    end

